'use strict';
/**
 * @module container
 */

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var graphUtil = require('../util/graph-util');
var parseLinks = graphUtil.parseLinks;
var vocab = require('solid-namespace');
var SolidResource = require('./resource');

/**
 * @class SolidContainer
 * @extends SolidResource
 * @constructor
 * @param rdf {RDF} RDF Library (such as rdflib.js) to inject
 * @param uri {string}
 * @param response {SolidResponse}
 */

var SolidContainer = function (_SolidResource) {
  _inherits(SolidContainer, _SolidResource);

  function SolidContainer(rdf, uri, response) {
    _classCallCheck(this, SolidContainer);

    /**
     * Hashmap of Containers within this container, keyed by absolute uri
     * @property containers
     * @type Object
     */
    var _this = _possibleConstructorReturn(this, (SolidContainer.__proto__ || Object.getPrototypeOf(SolidContainer)).call(this, rdf, uri, response));

    _this.containers = {};
    /**
     * List of URIs of all contents (containers and resources)
     * @property contentsUris
     * @type Array<string>
     */
    _this.contentsUris = [];
    /**
     * Hashmap of Contents that are just resources (not containers),
     * keyed by absolute uri
     * @property resources
     * @type Object
     */
    _this.resources = {};

    /**
     * Hashmap of common RDF ontology namespaces
     * @type Object
     */
    _this.vocab = vocab(rdf);

    if (_this.parsedGraph) {
      _this.appendFromGraph(_this.parsedGraph, _this.uri);
    }
    return _this;
  }

  /**
   * Extracts the contents (resources and sub-containers)
   * of the given graph and adds them to this container
   *
   * @method appendFromGraph
   * @param parsedGraph {Graph}
   * @param graphUri {string}
   */


  _createClass(SolidContainer, [{
    key: 'appendFromGraph',
    value: function appendFromGraph(parsedGraph, graphUri) {
      var _this2 = this;

      // Set this container's types
      var ns = this.vocab;
      var uriNode = this.rdf.namedNode(this.uri);
      this.types = Object.keys(parsedGraph.findTypeURIs(uriNode));

      // Extract all the contents links (resources and containers)
      var contentsUris = parseLinks(parsedGraph, null, ns.ldp('contains'));
      this.contentsUris = this.contentsUris.concat(contentsUris.sort());

      // Extract links that are just containers
      var containersLinks = parsedGraph.each(null, null, ns.ldp('Container'));

      var container = void 0;
      containersLinks.forEach(function (containerLink) {
        // Filter out . (the link to this directory)
        if (containerLink.uri !== _this2.uri) {
          container = new SolidContainer(_this2.rdf, containerLink.uri);
          container.types = Object.keys(parsedGraph.findTypeURIs(containerLink));
          _this2.containers[container.uri] = container;
        }
      });

      // Now that containers are defined, all the rest are non-container resources
      var isResource = void 0,
          isContainer = void 0;
      var resource = void 0,
          linkNode = void 0;
      contentsUris.forEach(function (link) {
        isContainer = link in _this2.containers;
        isResource = link !== _this2.uri && !isContainer;
        if (isResource) {
          resource = new SolidResource(_this2.rdf, link);
          linkNode = _this2.rdf.namedNode(link);
          resource.types = Object.keys(parsedGraph.findTypeURIs(linkNode));
          _this2.resources[link] = resource;
        }
      });
    }

    /**
     * Returns a list of SolidResource or SolidContainer instances that match
     * a given type.
     * @method findByType
     * @param rdfClass {string}
     * @return {Array<SolidResource|SolidContainer>}
     */

  }, {
    key: 'findByType',
    value: function findByType(rdfClass) {
      var matches = [];
      var key = void 0,
          container = void 0;

      for (key in this.containers) {
        container = this.containers[key];
        if (container.isType(rdfClass)) {
          matches.push(container);
        }
      }

      var resource = void 0;
      for (key in this.resources) {
        resource = this.resources[key];
        if (resource.isType(rdfClass)) {
          matches.push(resource);
        }
      }

      return matches;
    }

    /**
     * Is this a Container instance (vs a regular resource).
     * @return {Boolean}
     */

  }, {
    key: 'isContainer',
    value: function isContainer() {
      return true;
    }

    /**
     * Returns true if there are no resources or containers inside this container.
     * @method isEmpty
     * @return {Boolean}
     */

  }, {
    key: 'isEmpty',
    value: function isEmpty() {
      return this.contentsUris.length === 0;
    }
  }]);

  return SolidContainer;
}(SolidResource);

module.exports = SolidContainer;